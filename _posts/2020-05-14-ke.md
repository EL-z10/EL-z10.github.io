---
layout: post
title:  "壳及脱壳的一些基本办法"
date:   2020-05-14 21:18:21 +0800
tags:  reverse
color: rgb(98,170,255)
cover: '../assets/post/ke.jpg'
subtitle: '花式脱壳的学习'
---



有很多逆向题不能直接反汇编，第一步就得脱壳，这篇总结下脱壳的一些基本方法

# 什么是壳

##  目的及原理	

目的：压缩或保护（就是反逆向）

​	壳可以看做一段加密程序，即在原PE文件（后面称之为宿主文件）上加一个新的区段（也就是壳），然后从这个新的区段上开始运行。加壳后，原始程序代码在磁盘文件中以加密后的形式存在，只在执行时在内存中还原。防止程序被静态反编译和非法修改。如下图：

[![YDXbi6.png](https://s1.ax1x.com/2020/05/15/YDXbi6.png)](https://imgchr.com/i/YDXbi6)

​	有名的压缩壳有UPX,ASPack，加密壳有ASProtect,Armadillo,EXECryptor,Themidia...

​	这些大多有现成的脱壳机或者直接用kali解决，若碰到自编壳（如不用系统提供的GetProcAdress函数而是自编一个），只能手动脱壳。

## 常用词

`OEP`：程序的入口点（手动脱壳的重点！！）

`IAT`：导入地址表

由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中.当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。壳可能会对指针进行处理，修复输入表就是修复IAT

`段首和段尾`：段首,是上一段的结尾也是下一段的开头一段是以retn开始和retn结尾。我们经常听到在段首下断，所以我们要找的就是retn下面第一个push ,段首是以push开始滴，所以我们不会在retn那里下段而段尾我们是在retn处下断，因为软件的子程序是以retn返回到某一地方所以返回的时候要在retn出下断

`dump`:脱壳过程中的一个关键步骤，部分加密外壳会采取Aanti-Dump来防止被脱壳，得绕过

## ESP定律

ESP定律的原理就是“堆栈平衡”原理。

1、在命令行下断hresp-4（此时的ESP就是OD载入后当前显示的值）

2、hrESP(关键标志下一行代码所指示的ESP值(单步通过))

CALL

1.向堆栈中压入下一行程序的地址；

2.JMP到call的子程序地址处。

RETN

与call对应的就是RETN了。对于RETN我们可以这样来理解：

1.将当前的ESP中指向的地址出栈；

2.JMP到这个地址。

# 查壳

理论上可以hex查然鹅我还不知道（匿）

最简单快捷的就是用软件啦，比如`exeinfope`

![YDX7Ix.png](https://s1.ax1x.com/2020/05/15/YDX7Ix.png)

像这个就是UPX壳

# 具体脱壳办法

## 脱壳机

## kali

## 手动脱壳



