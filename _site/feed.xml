<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-16T00:45:11+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">welcome to my blog</title><subtitle></subtitle><author><name>true</name></author><entry><title type="html">壳及脱壳的一些基本办法（一）</title><link href="http://localhost:4000/2020/05/14/ke.html" rel="alternate" type="text/html" title="壳及脱壳的一些基本办法（一）" /><published>2020-05-14T21:18:21+08:00</published><updated>2020-05-14T21:18:21+08:00</updated><id>http://localhost:4000/2020/05/14/ke</id><content type="html" xml:base="http://localhost:4000/2020/05/14/ke.html">&lt;p&gt;有很多逆向题不能直接反汇编到我们需要的东东，第一步就得脱壳。这篇总结下脱壳的一些比较基础的方法。&lt;/p&gt;

&lt;h1 id=&quot;什么是壳&quot;&gt;什么是壳&lt;/h1&gt;

&lt;h2 id=&quot;目的及原理&quot;&gt;目的及原理&lt;/h2&gt;

&lt;p&gt;目的：压缩或保护（就是反逆向）&lt;/p&gt;

&lt;p&gt;​	壳可以看做一段加密程序，即在原PE文件（后面称之为宿主文件）上加一个新的区段（也就是壳），然后从这个新的区段上开始运行。加壳后，原始程序代码在磁盘文件中以加密后的形式存在，只在执行时在内存中还原。防止程序被静态反编译和非法修改。如下图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/YDXbi6&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YDXbi6.png&quot; alt=&quot;YDXbi6.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​	有名的压缩壳有UPX,ASPack，加密壳有ASProtect,Armadillo,EXECryptor,Themidia…&lt;/p&gt;

&lt;p&gt;​	这些大多有现成的脱壳机或者直接用kali解决，若碰到自编壳（如不用系统提供的GetProcAdress函数而是自编一个），只能手动脱壳。&lt;/p&gt;

&lt;h1 id=&quot;查壳&quot;&gt;查壳&lt;/h1&gt;

&lt;p&gt;最简单快捷的就是用软件啦，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;exeinfope&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;PEID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YDX7Ix.png&quot; alt=&quot;YDX7Ix.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;像这个就是UPX壳&lt;/p&gt;

&lt;h1 id=&quot;基础的脱壳办法&quot;&gt;基础的脱壳办法&lt;/h1&gt;

&lt;h2 id=&quot;找oep&quot;&gt;找OEP&lt;/h2&gt;

&lt;p&gt;​	当外壳所保护的程序运行时，会先执行外壳程序，外壳程序负责在内存中把原程序解压、还原， 并把控制权还给解压后的真正程序，再跳到原来的程序入口点。一般的壳在这里会有一条明显的“分 界线”，这个&lt;u&gt;解压后真正的程序入口点称为“OEP”&lt;/u&gt; （ Original Entry Point,原程序入口点)&lt;/p&gt;

&lt;p&gt;​	加壳后，原程序中多了一个区块.pediy。这个区块就是外壳，相当于一个文件加载器（Loader ）。当RebPE运行时，各区块被Windows操作系统映射到内存中，现在的入口点地址是13000h,指向 外壳。当外壳拿到控制权后，会通过各种方式获得自己所需要的API地址，解密原程序各区块的数 据，填充IAT（导入地址表）。做完这些工作后，就准备跳到OEP处（即401130h）执行，如图：&lt;/p&gt;

&lt;p&gt;​	&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YyZe0I.png&quot; alt=&quot;YyZe0I.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​	这也告诉我们：OEP总是与大跳如影随形（JMP,JZ）&lt;/p&gt;

&lt;p&gt;​	upx壳较为常见，一般使用cmd就很容易地可以脱掉&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UPX -d 文件名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​	在upx基础上，一些保护工具如UPXPR可以使以上命令行失效，这个时候就要用手动脱壳了（方法与ASPack类似）。以下就以加了UPXPR为例的记事本进行练习。附件在文末。&lt;/p&gt;

&lt;p&gt;先查壳&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YywFX9.png&quot; alt=&quot;YywFX9.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​	在很多基础的题目中，找OEP+Dump是一个脱壳通法，Dump可以用od直接搞定，故找OEP是重点。&lt;/p&gt;

&lt;p&gt;​	以下是几个找ESP常用方法。&lt;/p&gt;

&lt;h3 id=&quot;esp定律&quot;&gt;ESP定律&lt;/h3&gt;

&lt;h4 id=&quot;原理堆栈平衡&quot;&gt;原理：堆栈平衡&lt;/h4&gt;

&lt;p&gt;​	在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器值）与原程序的现场环境是相同的。通常用pushad/popad、pushfd/popfd来保存和恢复现场环境。&lt;strong&gt;&lt;u&gt;即OEP的寄存器值等于入口（PUSHAD）的寄存器值&lt;/u&gt;&lt;/strong&gt;，可利用硬件断点。&lt;/p&gt;

&lt;p&gt;​	思路：将最开始esp压栈地址的值下断点，找到下一个使个寄存器值与之全部相等的语句位置。&lt;/p&gt;

&lt;p&gt;​	注意，经验表明本方法可用范围：在pushad一次F8后，fpu里头的寄存器只有ESP是红的（EIP除外）&lt;/p&gt;

&lt;p&gt;​	另：PUSHAD相当于push eax/ecx/eddx/ebx/esp/esi/edi  (除EIP全压栈)&lt;/p&gt;

&lt;h4 id=&quot;操作&quot;&gt;操作&lt;/h4&gt;

&lt;p&gt;​	&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YyGaUe.png&quot; alt=&quot;YyGaUe.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;单步后只有ESP变了，可以用。&lt;/p&gt;

&lt;p&gt;1.右键ESP,跟随Dump&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YyJ2sx.png&quot; alt=&quot;YyJ2sx.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.选择弹出来的Hex Dump若干字符（多少无所谓），右键设置硬件byte断点（也不一定要byte)。这段就是一开始分析的入口和OEP一样的东东&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YytEjI.png&quot; alt=&quot;YytEjI.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以通过Debug-hardware breakpoints 检查设置得咋样&lt;/p&gt;

&lt;p&gt;3.&lt;code class=&quot;highlighter-rouge&quot;&gt;shift+F9&lt;/code&gt;运行看到popad和大跳&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YytJuq.png&quot; alt=&quot;YytJuq.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.F8单步，果然~（一般OEP很容易是PUSH,段首嘛）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YyNQZ6.png&quot; alt=&quot;YyNQZ6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5.dump脱壳，就是把起始地址从0040E941换成004010CC&lt;del&gt;（史前大跳）&lt;/del&gt;详见后文&lt;a href=&quot;#jump&quot;&gt;Dump操作&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;单步步进法&quot;&gt;单步步进法&lt;/h3&gt;

&lt;p&gt;效率较低但是最踏实。&lt;/p&gt;

&lt;p&gt;OD传统艺能，经典动态调试，总之就是&lt;strong&gt;只下不上&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;技巧：&lt;/p&gt;

&lt;p&gt;1.近CALL-F7,远CALL-F8,保证向下&lt;/p&gt;

&lt;p&gt;2.要是要回跳在下一句F4&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**3.关注大跳（JMP,JE,RETN)，很快就OEP**&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;按下不表&lt;del&gt;（其实是按到手酸QAQ）&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;内存镜像法&quot;&gt;内存镜像法&lt;/h3&gt;

&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;

&lt;p&gt;这个也叫两次断点法，原理：利用OD断点-执行-消断点这一自动过程可以跳过大量繁琐无意义代码。因为一般的壳会依次对.text、.rdata、.data、.rsrc区块解压处理，所以可以先在.rdata、.data、.rsrc区块设置内存访问断点，等到程序中断，&lt;u&gt;代码段就解压了&lt;/u&gt;，再对代码段.text设置内存访问断点，就可以直接到OEP&lt;/p&gt;

&lt;p&gt;1.ALT+M&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/16/YycGYn.png&quot; alt=&quot;YycGYn.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图，露出了三个完整的程序代码块。注意&lt;u&gt;**一定要是第一个程序代码块**&lt;/u&gt;，不能是DLL和壳的块。如图第一个设.data、.idata、.rsrc都行（其实本题.reloc只用设一次就欧了，但是重定位表一般情况下都会被删，所以一般还是看.rsrc）。断点-运行后再来第二次：.text,直接定到了OEP&lt;/p&gt;

&lt;h2 id=&quot;dump&quot;&gt;Dump&lt;/h2&gt;

&lt;h3 id=&quot;利用od&quot;&gt;利用OD&lt;/h3&gt;

&lt;p&gt;优点：简便。&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;jump&quot;&gt;缺点：不是所有都能Dump,比如对DLL映像&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在OEP语句右键-用OllydbgDump脱壳调试进程-脱壳（记得勾重建输入表-over&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YydcSe.png&quot; alt=&quot;YydcSe.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查壳，无壳状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/Yywi6J.png&quot; alt=&quot;Yywi6J.png&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;一些tips&quot;&gt;一些tips&lt;/h1&gt;

&lt;h2 id=&quot;od&quot;&gt;OD&lt;/h2&gt;

&lt;h3 id=&quot;快捷键&quot;&gt;快捷键&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+F2&lt;/code&gt;重载&lt;/p&gt;

&lt;p&gt;F2设断点，shift+F9运行&lt;/p&gt;

&lt;p&gt;遇到CALL,LOOP这些，F8路过，F7跟进&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alt+M&lt;/code&gt;打开内存镜像&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alt+O&lt;/code&gt;:Debugging options&lt;/p&gt;

&lt;h2 id=&quot;md&quot;&gt;md&lt;/h2&gt;

&lt;h3 id=&quot;页内跳转&quot;&gt;页内跳转&lt;/h3&gt;

&lt;p&gt;​	定义一个锚(id)：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span id=&quot;jump&quot;&amp;gt;跳转到的地方&amp;lt;/span&amp;gt;&lt;/code&gt;
​	使用markdown语法：&lt;code class=&quot;highlighter-rouge&quot;&gt;[点击跳转](#jump)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;快捷键-1&quot;&gt;快捷键&lt;/h3&gt;

&lt;p&gt;ctrl+B &lt;strong&gt;加粗&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ctrl+I &lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ctrl+U &lt;u&gt;下划线&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;Alt+shift+5  &lt;del&gt;划掉&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;ctrl+\  清除格式&lt;/p&gt;</content><author><name>true</name></author><category term="reverse" /><summary type="html">有很多逆向题不能直接反汇编到我们需要的东东，第一步就得脱壳。这篇总结下脱壳的一些比较基础的方法。</summary></entry><entry><title type="html">博客一些功能实现</title><link href="http://localhost:4000/2020/05/13/some-question-in-blog.html" rel="alternate" type="text/html" title="博客一些功能实现" /><published>2020-05-13T00:00:00+08:00</published><updated>2020-05-13T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/13/some%20question%20in%20blog</id><content type="html" xml:base="http://localhost:4000/2020/05/13/some-question-in-blog.html">&lt;h2 id=&quot;md插入图片问题&quot;&gt;md插入图片问题&lt;/h2&gt;

&lt;p&gt;先码个md&lt;a href=&quot;https://www.jianshu.com/p/280c6a6f2594&quot;&gt;加图语法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一开始想用相对路径，方法如下&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tian_ci/article/details/82909919&quot;&gt;https://blog.csdn.net/tian_ci/article/details/82909919&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/YrNKMt&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YrNKMt.png&quot; alt=&quot;YrNKMt.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此时md文件中可以正常显示图片，但是push到网上还是显示不出来。&lt;/p&gt;

&lt;p&gt;经查，jekyll不会复制_post文件里的资产，得放在根目录下一个&lt;code class=&quot;highlighter-rouge&quot;&gt;不是以下划线开头&lt;/code&gt;的文件夹里头。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YrNLQI.png&quot; alt=&quot;YrNLQI.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;遂把图片丢到/assets/images里面，md文件显示失败&lt;/p&gt;

&lt;p&gt;考虑可能是相对路径没用对？&lt;/p&gt;

&lt;p&gt;搜一下相对路径用法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./assets/&lt;/code&gt;这样写表示，当前目录中的assets文件夹
&lt;code class=&quot;highlighter-rouge&quot;&gt;../assets/&lt;/code&gt;这样写表示，当前目录的上一层目录中的assets文件夹
&lt;code class=&quot;highlighter-rouge&quot;&gt;/assets/&lt;/code&gt;这样写表示，项目根目录（可以指磁盘根目录，也可以指项目根目录，据实际情况而定）&lt;/p&gt;

&lt;p&gt;遂把图片丢到../assets/images里面，md文件显示失败（？）&lt;/p&gt;

&lt;p&gt;再来把图片丢到../assets里面，md文件显示成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/Yr0faV.png&quot; alt=&quot;Yr0faV.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而push上去还是显示不了。。。&lt;del&gt;心态崩了&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;这个亚子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/test1.png&quot; alt=&quot;test1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;换方法用图床。七猫云好麻烦QAQ，我自己用的&lt;a href=&quot;https://imgchr.com/&quot;&gt;路过图床&lt;/a&gt;，图传上去复制图片链接即可。（GitHub上建库也可）&lt;/p&gt;

&lt;p&gt;格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![图片名字]（图片链接）
![picture.png](https:/abc.com/123.png)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>true</name></author><category term="blog" /><summary type="html">md插入图片问题</summary></entry><entry><title type="html">jekyll 排错</title><link href="http://localhost:4000/2020/05/01/jekyll.html" rel="alternate" type="text/html" title="jekyll 排错" /><published>2020-05-01T14:05:21+08:00</published><updated>2020-05-01T14:05:21+08:00</updated><id>http://localhost:4000/2020/05/01/jekyll</id><content type="html" xml:base="http://localhost:4000/2020/05/01/jekyll.html">&lt;h2 id=&quot;解决办法&quot;&gt;解决办法&lt;/h2&gt;

&lt;h3 id=&quot;gemloaderror&quot;&gt;(Gem::LoadError)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D:\Github\EL-z10.github.io&amp;gt;jekyll -v
Traceback (most recent call last):
        10: from C:/Ruby26-x64/bin/jekyll:23:in `&amp;lt;main&amp;gt;'
         9: from C:/Ruby26-x64/bin/jekyll:23:in `load'
         8: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/jekyll-4.0.0/exe/jekyll:11:in `&amp;lt;top (required)&amp;gt;'
         7: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/jekyll-4.0.0/lib/jekyll/plugin_manager.rb:52:in `require_from_bundler'
         6: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-1.16.2/lib/bundler.rb:107:in `setup'
         5: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-1.16.2/lib/bundler/runtime.rb:26:in `setup'
         4: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-1.16.2/lib/bundler/runtime.rb:26:in `map'
         3: from C:/Ruby26-x64/lib/ruby/2.6.0/forwardable.rb:230:in `each'
         2: from C:/Ruby26-x64/lib/ruby/2.6.0/forwardable.rb:230:in `each'
         1: from C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-1.16.2/lib/bundler/runtime.rb:31:in `block in setup'
C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/bundler-1.16.2/lib/bundler/runtime.rb:313:in `check_for_activated_spec!': You have already activated i18n 1.8.2, but your Gemfile requires i18n 0.9.5. Prepending `bundle exec` to your command may solve this. (Gem::LoadError)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;处理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YDXNPf.png&quot; alt=&quot;YDXNPf.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;来自&lt;a href=&quot;https://superuser.com/questions/1483914/jekyll-serve-error-after-updating-ruby-bundler-and-jekyll&quot;&gt;https://superuser.com/questions/1483914/jekyll-serve-error-after-updating-ruby-bundler-and-jekyll&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;仅需在jekyll前键入bundle exec即可&lt;/p&gt;

&lt;h2 id=&quot;bundlergemnotfound&quot;&gt;(Bundler::GemNotFound)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YDXYIP.png&quot; alt=&quot;YDXYIP.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle update&lt;/code&gt;即可，不行的话再&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle install&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;一些tips&quot;&gt;一些tips&lt;/h2&gt;

&lt;p&gt;1.git bash中复制是&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+ins&lt;/code&gt;, 粘贴是&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+shift&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.jekyll serve 状态中本地网站无法跟踪_config.yml的变化（技术原因），若更改 _config.yml需先ctrl+c退出，y确定，再&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle exec jekyll serve&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.md文件名不能有中文，而且格式得是：2020-05-01-a title.md&lt;/p&gt;

&lt;p&gt;中文会404。&lt;/p&gt;</content><author><name>true</name></author><category term="blog" /><summary type="html">解决办法</summary></entry></feed>